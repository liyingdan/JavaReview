## 一、算法
### 1.算法的时间复杂度
 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。**算法的时间复杂度**，也就是算法的时间度量，记作：**T(n)=O(f(n))。**它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。
  
#### 1.1常见的时间复杂度
 常见的时间复杂度：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190903164534143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIxMDk2NQ==,size_16,color_FFFFFF,t_70)
   
 
#### 1.2最坏情况和平均情况
 最坏情况运行时间是一种保证，运行时间将不会再坏了。在应用中，这是一种最重要的需求，一般在没有特殊说明的情况下，都是指最坏时间复杂度。
  
  
  ### 2.算法的空间复杂度
   算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。
   
   
 ## 二、线性表
 线性表的抽象接口描述：
```java
public interface Ilist {
    //将存在的线性表置成空表
    void clear();
    //判断线性表是否为空
    boolean isEmpty();
    //求线性表中的数据元素个数（求线性表的长度）
    int length();
    //读取并返回线性表中的第i个数据元素的值
    Object get(int i);
    //在线性表的第i个数据元素之前插入一个值为x的数据元素
    void insert(int i, Object x);
    //删除并返回线性表中第i个数据元素
    void remove(int i);
    //返回线性表中首次出现指定数据元素的位序号
    int indexOf(Object x);
    //输出线性表中各个元素的值
    void display();
}
```
### 1.线性表的顺序存储
可以用数组来描述数据元素中的顺序存储结构，其中数组元素的个数对应存储区域的大小，假设为maxSize。考虑到线性表的长度是可变的，故还需要用一个变量curLen来记录线性表的实际长度。线性表的顺序存储结构在线性表Java接口的实现类如下：
```java
public class SqList implements Ilist {
    private Object[] listElem; //线性表存储空间
    private int curLen; //线性表的当前长度
    .
    .
    .
}
```
根据上述描述，对于线性表（34,12,25,61,30,49），其顺序存储结构如图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190903205045279.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIxMDk2NQ==,size_16,color_FFFFFF,t_70)
###### 线性表类的描述如下：

```java
public class SqList implements Ilist {
    private Object[] listElem; //线性表存储空间
    private int curLen; //线性表的当前长度

    public SqList(int maxSize){
        curLen = 0;
        listElem = new Object[maxSize];
    }

    @Override
    public void clear() {
        curLen = 0;
    }

    @Override
    public boolean isEmpty() {
        return curLen == 0;
    }

    @Override
    public int length() {
        return curLen;
    }

    /**
     * 读取并返回线性表中的第i个数据元素的值
     * */
    @Override
    public Object get(int i) throws Exception {
        if(i < 0 || i > curLen-1 ){
            throw new Exception("该元素不存在");
        }
        return listElem[i];
    }

    /**
     * 在线性表的第i个数据元素之前插入一个值为x的数据元素
     * */
    @Override
    public void insert(int i, Object x) throws Exception {
        if(curLen == listElem.length)
            throw new Exception("顺序表已满");
        if(i < 0 || i > curLen)
            throw new Exception("插入位置不正确");

        for(int j = curLen; j > i; j--)
            listElem[j] = listElem[j-1];

        listElem[i] = x;
        curLen ++;
    }

    /**
     * 删除并返回线性表中第i个数据元素
     * */
    @Override
    public void remove(int i) throws Exception {
        if(i < 0 || i > curLen-1)
            throw new Exception("删除位置不正确");
        for (int j = i; j< curLen-1; j++)
            listElem[j] = listElem[j+1];
        curLen --;
    }

    /**
     * 返回线性表中首次出现指定数据元素的位序号
     * */
    @Override
    public int indexOf(Object x) {
        int j = 0;
        while (j < curLen && !listElem[j].equals(x)) //依次比较
            j++;
        if(j < curLen)
            return j;
        else
            return -1;
    }

    @Override
    public void display() {
        for (int j = 0; j < curLen; j++) {
            System.out.println(listElem[j]);
        }

    }
}
```


### 2.线性表的链式存储
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190903205148558.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIxMDk2NQ==,size_16,color_FFFFFF,t_70)
单链表是由若干个结点连接而成的，因此，要实现单链表，首先要设计结点类。其中，data是数据域，用来存放数据元素的值；next是指针域，用来存放后继结点的地址。

```java
public class Node {
    public Object data;
    public Node next;
    public Node(){
        this(null,null);
    }
    public Node(Object data){
        this(data,null);
    }
    public Node(Object data, Node next){
        this.data = data;
        this.next = next;
    }
}
```
 ###### 单链表类的描述

```java
public class LinkList implements Ilist {
    public Node head; //单链表的头指针

    public LinkList(){ //单链表的构造函数
        head = new Node(); //初始化头结点
    }
```
- 单链表的建立操作：

```java
    /**
     * 构造一个长度为n的单链表
     * */
    public LinkList(int n){
        //头插法

        //尾插法

    }
```

```java
 @Override
    public void clear() {
        head.data = null;
        head.next = null;

    }

    @Override
    public boolean isEmpty() {
        return head.next == null;
    }

    @Override
    public int length() {
        Node p = head.next;
        int length = 0;
        if(p != null){
            p = p.next;
            ++ length;
        }
        return length;
    }
```
- <font color ="oriange">读取带头结点的单链表中的第i个结点</font>
```java
/**
     * 读取带头结点的单链表中的第i个结点
     * */
    @Override
    public Object get(int i) throws Exception {
        Node p = head.next;
        int j = 0;
        while (p != null && j< i){
            p = p.next;
            ++ j;
        }
        if(j > i || p == null) {
            throw new Exception("元素不存在");
        }
        return p.data;
    }
```
- <font color ="red">在单链表中的第i个结点之前插入一个值为x的新结点</font>
```java
/**
     * 在带头结点的单链表中的第i个结点之前插入一个值为x的新结点
     * */
    @Override
    public void insert(int i, Object x) throws Exception {
    	Node p = head;
        int j = -1;
        while (p != null && j < i-1){
            p = p.next;
            ++ j;
        }
        if(j > i-1 || p == null){
            throw new Exception("插入位置不合法");
        }
        Node s = new Node(x);
        s.next = p.next;
        p.next = s;

    }
```
```java
 /**
     * 在不带头结点的单链表中的第i个结点之前插入一个值为x的新结点
     * */
     public void insert1(int i, Object x) throws Exception{
        Node p = head;
        int j = 0;
        while (p != null && j < i-1){
            p = p.next;
            ++ j;
        }
        if(j > i || p == null){
            throw new Exception("插入位置不合法");
        }
        Node s = new Node(x);
        if(i == 0){
            s.next = head;
            head = s;
        }else {
            s.next = p.next;
            p.next = s;
        }
    }
```
- <font color ="blue">删除带头结点的单链表中的第i个结点</font>
```java
/**
     * 删除带头结点的单链表中的第i个结点
     * */
    @Override
    public void remove(int i) throws Exception {
        Node p = head;
        int j = -1;
        while (p.next != null && j < i-1){
            p = p.next;
            ++ j;
        }
        if(j > i-1 || p.next == null){
            throw new Exception("删除位置不合法");
        }
        p.next = p.next.next;

    }
```

```java
/**
     * 在带头结点的单链表删除数据域值为x的结点
     * */
     public void remove1(Object x) throws Exception {
        Node p = head;
        while (p.next != null && p.next.data != x){
            p = p.next;
        }
        if(p.next == null){
            throw new Exception("删除结点不存在");
        }
        p.next = p.next.next;

    }

```

- 按值查找操作算法
```java
/**
     * 在带头结点的单链表中查找值为x的结点
     * */
    @Override
    public int indexOf(Object x) {
       	Node p = head.next;
        int j = 0;
        while (p != null && !p.data.equals(x)){
            p = p.next;
            ++ j;
        }
        if(p != null)
            return j;
        else
            return -1;
    }
```

```java
    @Override
    public void display() {
        Node node = head.next;
        while (node != null){
            System.out.print(node.data+" ");
            node = node.next;
        }
        System.out.println();
    }
}
```

 
 
 
   
   
 ## 三、栈与队列
 
 
 
   
   
 ## 四、树




  
  
 ## 五、查找
 
 
 
 
 
   
   
 ## 六、排序
